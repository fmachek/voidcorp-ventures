extends Node2D
class_name Planet
## This class represents a planet object in the game. It is the game's main focus.

## Planets have different types which control the types of resources
## present on them for example.
enum PlanetType {NORMAL, LIFE, COLD, HOT}

## The planet type (normal/life/cold/hot).
var planet_type: PlanetType

## Preloaded Spaceship scene.
@onready var spaceship_scene = preload("res://scenes/gameobjects/spaceships/Spaceship.tscn")

## The main game camera.
@onready var camera: Camera2D = $"/root/Game/MainCamera"
## The planet's highlight sprite.
@onready var highlight: Sprite2D = $PlanetHighlightSprite
## The planet's sprite.
@onready var sprite: Sprite2D = $PlanetSprite
## The game's UI layer.
@onready var ui_layer: UILayer = $"/root/Game/UILayer"
## The game's planet UI.
@onready var planet_ui: PlanetUI = $"/root/Game/UILayer/GameUI/PlanetUI"
## Planet's child timer.
@onready var timer: Timer = $Timer
## Timer used to time bonus resource mining
@onready var bonus_timer: Timer = $BonusTimer
## Timer used during production downtime to time complete planet loss
@onready var loss_timer: Timer = $LossTimer
## Button click sound player.
@onready var button_click_player = $"/root/Game/ButtonClickPlayer"

## First [ResourceCurrency] generated by the planet.
var resource1: ResourceCurrency
## Second [ResourceCurrency] generated by the planet.
var resource2: ResourceCurrency
## The name of the first refined resource.
var refined_resource_name1: String
## The name of the second refined resource.
var refined_resource_name2: String

## This variable indicates whether the planet is owned by the player or not.
@export var owned : bool = false
## The planet name.
@export var planet_name: String = "Planet"
## Indicates whether the planet is the home planet or not.
@export var is_home_planet: bool = false

## This variable indicates the amount of factories present on the planet.
var factories : int = 0
## This variable indicates the amount of mines present on the planet.
var mines : int = 0
## Array of spaceships present on the planet.
var spaceships: Array = []
## Planet inventory, where mined resources are stored.
var inventory: Inventory = Inventory.new()
## Indicates whether the production of resources is paused or not.
var is_production_halted: bool = false
## Production downtime in seconds.
var downtime_seconds: int = 0

## Indicates if the planet can mine bonus resources.
var can_mine_bonus_resources: bool = false
## The amount of bonus resources that can be mined every bonus tick.
var bonus_resource_amount: int = 1
## The planet's boost zone.
var boost_zone: BoostZone = null
## Indicates if boost zones are unlocked.
var is_boost_zone_unlocked: bool = false
## Multiplier of the chance to mine Gravitium.
var gravitium_multiplier: float = 0
## Bonus Gravitium chance.
var gravitium_bonus_chance: float = 0

## Line2D used during the SENDING_SPACESHIP input mode to connect this
## [Planet] with the [Planet] currently being hovered over.
var connecting_line: Line2D

## This signal is emitted when the first resource changes.
signal resource1_changed(new_value: int)
## This signal is emitted when the second resource changes.
signal resource2_changed(new_value: int)
## Emitted when a spaceship lands on this planet.
signal spaceship_landed(spaceship: Spaceship)
## Emitted when a spaceship departs from this planet.
signal spaceship_left(spaceship: Spaceship)

## Emitted when the planet is claimed.
signal claimed()
## Emitted when the planet is lost.
signal lost()
## Emitted when the production halts.
signal production_halted()
## Emitted when the production resumes.
signal production_resumed()
## Emitted when production downtime in seconds changed.
signal downtime_passed(new_seconds: int)

signal mine_built()
signal mine_lost()
signal factory_built()
signal factory_lost()


func _ready() -> void:
	timer.connect('timeout', _on_timer_timeout)
	bonus_timer.connect('timeout', mine_bonus_resource)
	
	connect_upgrades()


## Chooses the resources based on the planet type.
func choose_resources() -> void:
	if planet_type == null:
		choose_planet_type()
	
	var resources: Array
	match planet_type:
		PlanetType.NORMAL, PlanetType.LIFE: resources = ResourceManager.choose_normal_resources()
		PlanetType.COLD: resources = ResourceManager.choose_cold_resources()
		PlanetType.HOT: resources = ResourceManager.choose_hot_resources()
	
	resource1 = resources[0]
	resource2 = resources[1]
	refined_resource_name1 = ResourceManager.get_refined_resource_name(resource1)
	refined_resource_name2 = ResourceManager.get_refined_resource_name(resource2)


## Draws the circle around the planet, indicating if it's claimed or lost.
func _draw():
	if owned:
		var circle_color: Color
		if is_production_halted:
			circle_color = Color("#a30000")
		else:
			circle_color = Color("#00ab00")
		draw_arc(Vector2(0, 0), 20, 0, TAU, 128, circle_color, 1)


## Redraws every frame.
func _process(delta: float) -> void:
	queue_redraw()


## This function is called when the player's mouse enters the
## planet's [Area2D].[br]
## The highlight sprite is shown. Then, the current input mode is
## checked and the appropriate function is called.
func _on_area_2d_mouse_entered() -> void:
	highlight.visible = true # show the planet highlight
	var input_mode = InputModeHandler.current_input_mode
	if input_mode == InputModeHandler.InputMode.NORMAL:
		normal_mouse_enter_action()
	elif input_mode == InputModeHandler.InputMode.SENDING_SPACESHIP:
		spaceship_mouse_enter_action()


## This function is called when the player's mouse exits the
## planet's [Area2D].[br]
## The highlight sprite is hidden. Then, the current input mode is
## checked and the appropriate function is called.
func _on_area_2d_mouse_exited() -> void:
	highlight.visible = false # hide the planet highlight
	var input_mode = InputModeHandler.current_input_mode
	if input_mode == InputModeHandler.InputMode.NORMAL:
		normal_mouse_leave_action()
	elif input_mode == InputModeHandler.InputMode.SENDING_SPACESHIP:
		spaceship_mouse_leave_action()


## This function is called when an input event happens.[br]
## If the event is a left mouse button click, then the input mode is checked
## and the appropriate function is called.
func _on_area_2d_input_event(viewport: Node, event: InputEvent, shape_idx: int) -> void:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			var input_mode = InputModeHandler.current_input_mode
			if input_mode == InputModeHandler.InputMode.NORMAL:
				normal_mouse_click_action()
			elif input_mode == InputModeHandler.InputMode.SENDING_SPACESHIP:
				spaceship_mouse_click_action()


## Chooses the planet type. If the planet is the home planet,
## then the type is always LIFE. Otherwise, it's random, but
## normal planets have a much higher chance of being generated.
func choose_planet_type():
	if is_home_planet:
		planet_type = PlanetType.LIFE
	else:
		var chance = randi_range(0, 100)
		if chance < 80:
			planet_type = PlanetType.NORMAL
		elif chance < 85:
			planet_type = PlanetType.COLD
		elif chance < 90:
			planet_type = PlanetType.HOT
		else:
			planet_type = PlanetType.LIFE


## Chooses a random texture for its sprite based on the planet type.
func choose_texture():
	if planet_type == null:
		return
	
	if is_home_planet:
		var res_path: String = "res://assets/sprites/planets/homeplanet.png"
		sprite.texture = load(res_path)
	else:
		match planet_type:
			PlanetType.NORMAL: sprite.texture = TextureLoader.load_random_normal_planet_texture()
			PlanetType.COLD: sprite.texture = TextureLoader.load_random_cold_planet_texture()
			PlanetType.HOT: sprite.texture = TextureLoader.load_random_hot_planet_texture()
			PlanetType.LIFE: sprite.texture = TextureLoader.load_random_life_planet_texture()


## Builds a new mine. If there is one mine,
## the mining timers start.
func build_mine():
	mines += 1
	if mines == 1:
		timer.start()
		if can_mine_bonus_resources:
			bonus_timer.start()
	emit_signal("mine_built")
	return mines

## Destroys a mine. If there are zero mines,
## the mining timers stop.
func destroy_mine():
	if mines - 1 >= 0:
		mines -= 1
	if mines == 0:
		timer.stop()
		if can_mine_bonus_resources:
			bonus_timer.stop()
	emit_signal("mine_lost")
	return mines


## Builds a new factory.
func build_factory():
	factories += 1
	emit_signal("factory_built")
	return factories


## Destroys a factory.
func destroy_factory():
	if factories - 1 >= 0:
		factories -= 1
	emit_signal("factory_lost")
	return factories


## This function handles the timer timeout. Both resources are drained on each timeout.
## There is a chance to mine Gravitium if the player has unlocked the
## upgrade for it. The resources are also transformed into their more expensive
## counterparts if there are any factories.
func _on_timer_timeout() -> void:
	var mined_resources = mine_resources()
	var mined_resource1: int = mined_resources[0]
	var mined_resource2: int = mined_resources[1]
	
	var refined_resource1 = refine_resource(mined_resource1)
	var refined_resource2 = refine_resource(mined_resource2)
	
	mined_resource1 -= refined_resource1
	mined_resource2 -= refined_resource2
	
	var gravitium: int = look_for_gravitium()
	
	if is_home_planet: # Get resources right away
		GameManager.add_resource(resource1.name, mined_resource1)
		GameManager.add_resource(resource2.name, mined_resource2)
		GameManager.add_resource(refined_resource_name1, refined_resource1)
		GameManager.add_resource(refined_resource_name2, refined_resource2)
		GameManager.add_resource("Gravitium", gravitium)
		spawn_gain_labels(mined_resource1, mined_resource2, refined_resource1, refined_resource2, gravitium)
	else: # Put resources into inventory, spaceships have to carry them to home planet
		inventory.add_resource(ResourceCurrency.new(resource1.name, mined_resource1))
		inventory.add_resource(ResourceCurrency.new(resource2.name, mined_resource2))
	
		if refined_resource1 > 0:
			inventory.add_resource(ResourceCurrency.new(refined_resource_name1, refined_resource1))
		if refined_resource2 > 0:
			inventory.add_resource(ResourceCurrency.new(refined_resource_name2, refined_resource2))
		if gravitium > 0:
			inventory.add_resource(ResourceCurrency.new("Gravitium", gravitium))


## Attempts to mine Gravitium. Displays a visual effect
## when it is found.
func look_for_gravitium() -> int:
	var chance = calculate_gravitium_chance()
	if randf() < (chance / 100.0):
		var gravitium_particles: CPUParticles2D = $GravitiumParticles
		gravitium_particles.emitting = true
		ConsoleMessageManager.add_info_message("Gravitium has been found on planet " + planet_name + "!")
		return 1
	else:
		return 0


## Spawns resource gain labels to notify the player.
func spawn_gain_labels(mined_resource1: int, mined_resource2: int, refined_resource1: int, refined_resource2: int, gravitium: int) -> void:
	var resources = {}
	var x_offset = 5
	var y_offset = 9
	
	if mined_resource1 > 0:
		resources[resource1.name] = mined_resource1
	if  mined_resource2 > 0:
		resources[resource2.name] = mined_resource2
	if  refined_resource1 > 0:
		resources[refined_resource_name1] = refined_resource1
	if refined_resource2 > 0:
		resources[refined_resource_name2] = refined_resource2
	if gravitium > 0:
		resources["Gravitium"] = gravitium
	var i = 1
	for resource_name in resources:
		var resource_amount = resources[resource_name]
		var text = "+" + str(resource_amount) + " " + resource_name
		ResourceGainLabelSpawner.spawn_label(text, global_position + Vector2(x_offset, y_offset*i))
		i += 1


## This function mines the resources present on the planet.
## The amount of mined resources depends on the amount of mines.
## The resources can also be drained completely.
func mine_resources():
	if resource1.amount == 0 and resource2.amount == 0:
		return [0, 0]
	var mined_resource1 = 0
	var mined_resource2 = 0
	if resource1.amount > 0:
		mined_resource1 = resource1.subtract(mines)
		emit_signal('resource1_changed', resource1.amount)
	if resource2.amount > 0:
		mined_resource2 = resource2.subtract(mines)
		emit_signal('resource2_changed', resource2.amount)
	emit_mine_particles()
	return [mined_resource1, mined_resource2]


## Refines resources using the factories.
func refine_resource(resource_amount: int):
	var refine_rate = factories * 2 # 2 refinements per factory
	if refine_rate >= resource_amount:
		return resource_amount; # Refine everything
	else:
		return refine_rate;


## This function shows the planet tooltip.
func normal_mouse_enter_action():
	ui_layer.show_planet_tooltip(self)


## This function hides the planet tooltip.
func normal_mouse_leave_action():
	ui_layer.hide_planet_tooltip(self)


## This function loads the [PlanetUI] with this [Planet] if owned.
## The camera also focuses on it.
func normal_mouse_click_action():
	if owned:
		button_click_player.play() # play the click sound
		camera.focus_on(self) # focus camera on the planet
		planet_ui.load_ui(self)


## This function is called when the player's mouse enters the [Planet]'s [Area2D]
## during the SENDING_SPACESHIP input mode.[br]
## A line connecting the source and destination [Planet] is shown.
func spaceship_mouse_enter_action():
	if not connecting_line:
		connecting_line = Line2D.new()
		connecting_line.width = 4
		connecting_line.add_point(InputModeHandler.spaceship_source.global_position)
		connecting_line.add_point(self.global_position)
		connecting_line.z_index = 100
		GameManager.add_child(connecting_line)
	else:
		connecting_line.set_point_position(0, InputModeHandler.spaceship_source.global_position)
		connecting_line.visible = true
	
	var source_planet: Planet = InputModeHandler.spaceship_source
	if source_planet != self: # Spaceship source is not this planet
		var spaceship: Spaceship = InputModeHandler.current_spaceship_controlled
		var fuel_price: int = spaceship.calculate_fuel(source_planet, self)
		
		var fuel_price_label: FuelPriceLabel = $"/root/Game/UILayer/GameUI/FuelPriceLabel"
		fuel_price_label.show_price(fuel_price)


## This function is called when the player's mouse exits the [Planet]'s [Area2D]
## during the SENDING_SPACESHIP input mode.[br]
## The connecting [Line2D] is hidden.
func spaceship_mouse_leave_action():
	if connecting_line:
		connecting_line.visible = false
	var fuel_price_label = $"/root/Game/UILayer/GameUI/FuelPriceLabel"
	fuel_price_label.visible = false


## This function is called when the player's mouse clicks on the [Planet]
## during the SENDING_SPACESHIP input mode.[br]
## A spaceship is sent to this [Planet] if it's not the source.
## The input mode is also reset to NORMAL.
func spaceship_mouse_click_action():
	var spaceship_source: Planet = InputModeHandler.spaceship_source
	var spaceship: Spaceship = InputModeHandler.current_spaceship_controlled
	if self != spaceship_source:
		var fuel_price: int = spaceship.calculate_fuel(InputModeHandler.spaceship_source, self)
		if GameManager.has_enough_money(fuel_price):
			button_click_player.play()
			InputModeHandler.end_spaceship_control()
			
			var fuel_price_label = $"/root/Game/UILayer/GameUI/FuelPriceLabel"
			fuel_price_label.visible = false
			connecting_line.visible = false
			
			spaceship.fly(spaceship_source, self)


## A new spaceship is built on this planet.
func build_spaceship() -> Spaceship:
	var spaceship: Spaceship = spaceship_scene.instantiate()
	spaceship.scale = Vector2(0, 0)
	spaceship.position = self.global_position
	get_node('/root/Game/Level/Spaceships').add_child(spaceship)
	land_spaceship(spaceship)
	return spaceship


## A spaceship lands on the planet. If the planet isn't owned,
## the player claims it.
func land_spaceship(spaceship: Spaceship) -> void:
	spaceships.append(spaceship)
	spaceship.current_planet = self
	emit_signal('spaceship_landed', spaceship)
	if not owned:
		owned = true
		GameManager.planet_claimed()
		ConsoleMessageManager.add_info_message("You have claimed planet " + planet_name + ".")
		
		emit_signal('claimed')


## A given spaceship takes off from the planet.
func takeoff_spaceship(spaceship: Spaceship) -> void:
	if spaceship in spaceships:
		spaceships.erase(spaceship)
	emit_signal('spaceship_left', spaceship)


## Production of resources halts on the planet.
func halt_production() -> void:
	if is_production_halted:
		return
	is_production_halted = true
	timer.paused = true # Pause the production timer
	if can_mine_bonus_resources:
		if mines > 0:
			bonus_timer.paused = true
	downtime_seconds = 0
	loss_timer.start()
	ConsoleMessageManager.add_warning_message("Production has halted on planet " + planet_name + ".", focus_camera_on_planet)
	emit_signal("production_halted")


## Production of resources resumes on the planet.
func resume_production() -> void:
	is_production_halted = false
	loss_timer.stop()
	downtime_seconds = 0
	timer.paused = false # Resume the production timer
	if can_mine_bonus_resources:
		if mines > 0:
			bonus_timer.paused = false
	ConsoleMessageManager.add_info_message("Production has resumed on planet " + planet_name + ".")
	emit_signal("production_resumed")


## Handles meteor collisions. If the planet is owned,
## a meteor impact always causes the production to halt.
func handle_meteor_collision() -> void:
	if owned:
		halt_production()


## Builds a crew ship on the planet.
func build_crew_ship() -> CrewShip:
	var crew_ship_scene = load("res://scenes/gameobjects/meteors/CrewShip.tscn")
	var crew_ship: CrewShip = crew_ship_scene.instantiate()
	var crew_ships = $"/root/Game/Level/CrewShips"
	crew_ships.add_child(crew_ship)
	return crew_ship


## Sends the crew ship in the direction toward its destination.
func send_crew_ship(destination: Vector2) -> void:
	var crew_ship: CrewShip = build_crew_ship()
	crew_ship.fly_to(self, destination)


## Mines bonus resources, even after they have been drained.
## This can only happen if the player has unlocked the necessary
## upgrade.
func mine_bonus_resource() -> void:
	var chance: int = randi_range(0, 1)
	var resource_name: String
	if chance == 0:
		resource_name = resource1.name
	else:
		resource_name = resource2.name
	var amount = randi_range(1, bonus_resource_amount)
	if is_home_planet:
		GameManager.add_resource(resource_name, amount)
		var text = "+ " + str(amount) + " " + resource_name
		ResourceGainLabelSpawner.spawn_label(text, global_position + Vector2(-100, 0))
	else:
		inventory.add_resource(ResourceCurrency.new(resource_name, amount))


## Checks if the upgrades are unlocked. If they are, they are applied. Otherwise,
## their unlock signals are connected.
func connect_upgrades() -> void:
	var bonus_resource_upgrade: Upgrade = UpgradeManager.upgrades[11]
	if bonus_resource_upgrade.is_unlocked:
		unlock_bonus_resources()
	else:
		bonus_resource_upgrade.connect('unlocked', unlock_bonus_resources)
	
	var bonus_resource_speed_upgrade: Upgrade = UpgradeManager.upgrades[12]
	if bonus_resource_speed_upgrade.is_unlocked:
		unlock_bonus_resource_speed()
	else:
		bonus_resource_speed_upgrade.connect('unlocked', unlock_bonus_resource_speed)
	
	var bonus_resource_amount_upgrade: Upgrade = UpgradeManager.upgrades[13]
	if bonus_resource_amount_upgrade.is_unlocked:
		unlock_bonus_resource_amount()
	else:
		bonus_resource_amount_upgrade.connect('unlocked', unlock_bonus_resource_amount)
	
	var boost_zone_upgrade: Upgrade = UpgradeManager.upgrades[16]
	if boost_zone_upgrade.is_unlocked:
		unlock_boost_zone()
	else:
		boost_zone_upgrade.connect('unlocked', unlock_boost_zone)
	
	var gravitium_upgrade = UpgradeManager.upgrades[22]
	if gravitium_upgrade.is_unlocked:
		unlock_gravitium()
	else:
		gravitium_upgrade.connect('unlocked', unlock_gravitium)
	
	var gravitium_chance_upgrades = [UpgradeManager.upgrades[23], UpgradeManager.upgrades[24], UpgradeManager.upgrades[25]]
	for upgrade: Upgrade in gravitium_chance_upgrades:
		if upgrade.is_unlocked:
			increase_gravitium_chance()
		else:
			upgrade.connect('unlocked', increase_gravitium_chance)


## Unlocks the ability to occasionally mine resources even after
## they have been drained.
func unlock_bonus_resources() -> void:
	can_mine_bonus_resources = true
	if owned:
		if not is_production_halted and mines > 0:
			bonus_timer.start()


## Increases the speed at which bonus resources are mined.
func unlock_bonus_resource_speed() -> void:
	bonus_timer.wait_time -= 5


## Allows 2 of a bonus resource be mined instead of 1.
func unlock_bonus_resource_amount() -> void:
	bonus_resource_amount = 2


## Unlocks the planet's boost zone.
func unlock_boost_zone() -> void:
	is_boost_zone_unlocked = true
	# If the planet is owned, spawn now
	# Also spawn when claimed
	if owned:
		spawn_zone()
	connect('claimed', spawn_zone)


## Spawns the planet's boost zone.
func spawn_zone() -> void:
	var boost_zone_scene = load("res://scenes/gameobjects/spaceships/BoostZone.tscn")
	boost_zone = boost_zone_scene.instantiate()
	add_child(boost_zone)
	boost_zone.global_position = self.global_position


## Makes this planet the home planet.
func set_to_home_planet() -> void:
	is_home_planet = true
	load_home_planet_icon()
	name = "Home Planet"
	planet_name = "Home Planet"


## Loads the home planet icon.
func load_home_planet_icon() -> void:
	var home_planet_icon: Sprite2D = Sprite2D.new()
	home_planet_icon.texture = load("res://assets/sprites/planets/homeplaneticon.png")
	add_child(home_planet_icon)
	home_planet_icon.position = Vector2.ZERO
	home_planet_icon.scale = Vector2(1.5, 1.5)


## Deposits some of the planet's inventory to a spaceship's cargo.
func depsoit_inventory_to_spaceship(spaceship: Spaceship) -> void:
	var deposited: int = 1
	while deposited > 0:
		var highest_resource: ResourceCurrency = inventory.get_highest_resource()
		deposited = spaceship.cargo.add_resource_to_cargo(highest_resource)
		inventory.withdraw_resource(highest_resource, deposited)


## Increases the chance to find Gravitium by 0.5%.
func increase_gravitium_chance() -> void:
	gravitium_bonus_chance += 0.5


## Unlocks the ability to mine Gravitium.
func unlock_gravitium() -> void:
	if gravitium_multiplier == 0:
		gravitium_multiplier = 1


## Calculates Gravitium chance, which depends on the amount of mines
## built on the planet.
func calculate_gravitium_chance() -> float:
	match mines:
		1: return 0.5 * gravitium_multiplier + gravitium_bonus_chance
		2: return 1.5 * gravitium_multiplier + gravitium_bonus_chance
		3: return 3 * gravitium_multiplier + gravitium_bonus_chance
		_: return 5 * gravitium_multiplier + gravitium_bonus_chance


## Causes the planet to be lost, which destroys your mines, factories, spaceships
## and removes the boost zone. The player has to reclaim it.
func lose_planet() -> void:
	lose_all_mines()
	lose_all_factories()
	timer.paused = false
	timer.stop()
	bonus_timer.stop()
	bonus_timer.paused = false
	owned = false
	is_production_halted = false
	inventory.empty()
	
	var boost_zone: BoostZone = get_node("BoostZone")
	if boost_zone:
		boost_zone.queue_free()
	
	for spaceship: Spaceship in spaceships:
		spaceship.destroy()
	spaceships.clear()
	
	GameManager.planet_lost()
	ConsoleMessageManager.add_warning_message("You have lost planet " + planet_name + ".", focus_camera_on_planet)
	emit_signal("lost")
	
	if is_home_planet: # Lose the game if the home planet is lost.
		GameManager.lose_game()


## Increases the downtime passed when the loss timer times out.
## If 60 seconds have passed, the player loses the planet.
func _on_loss_timer_timeout() -> void:
	downtime_seconds += 1
	emit_signal("downtime_passed", downtime_seconds)
	
	if downtime_seconds == 60:
		lose_planet()


func _on_meteor_detector_area_2d_entered(area: Area2D) -> void:
	var parent = area.get_parent()
	if parent is Meteor:
		var resource: ResourceCurrency = parent.rare_resource
		if resource != null:
			ConsoleMessageManager.add_info_message("A meteor containing " + resource.name + " is near planet " + planet_name + "!")


func focus_camera_on_planet() -> void:
	camera.target = null
	camera.zoom_in()
	camera.global_position = global_position


## Emits particles that indicate that resources have been mined.
func emit_mine_particles() -> void:
	var particles: CPUParticles2D = $MineParticles
	particles.emitting = true


func lose_all_mines() -> void:
	for i in range(mines):
		mines -= 1
		emit_signal("mine_lost")


func lose_all_factories() -> void:
	for i in range(factories):
		factories -= 1
		emit_signal("factory_lost")
